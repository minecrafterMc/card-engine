<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      @font-face {
        font-family: lato;
        src: url(/assets/fonts/lato/Lato-Black.ttf);
      }
      canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        left: 0px;
        top: 0px;
      }
      </style>
  </head>
  <body></body>
  <script src="/libs/phaser.js"></script>
  <script src="/engine.js"></script>
  <script src="/card-generator"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    console.log(io);
    const socket = io();
    socket.on("connection", (e) => {
      
    });
    const cardColors = { h: "red", d: "#9e5515", s: "black", c: "blue" };
    const cardValues = ["A", 2, 3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K"];
    const shapes = {};
    var cards = {};
    const loadedImgs = {};
    const mouseMovementScale = 10;
    var opponentCards = [];
    var camera;
    var handGroup;
    var deckCard;
    var placedCard;
    var backgroundImg;
    var table;
    var playersMenu;
    var dutchButton;
    var animationCard = [];
    var replaceMode = false;
    var replaceFromMainDeck = true;
    var revealMode = false;
    var revealAmount = 0;
    var scene;
    var animationData = [];
    var playerList;
    var playerListObjects = [];
    var playerListArrowObject;
    var selectedOpponent = 0;
    const loadPromise = new Promise((resolve, reject) => {
      let loaded = 0;
      for (let i = 0; i < Object.keys(cardColors).length; i++) {
        const color = Object.keys(cardColors)[i];
        shapes[color] = new shape(
          cardColors[color],
          "/assets/" + color + "_symbol.png",
          function () {
            loaded++;
          },
        );
      }
      var checker = setInterval(() => {
        if (loaded >= 4) {
          clearInterval(checker);
          resolve();
        }
      }, 100);
    }).then(function() {
      cards = [];
      for (let value of cardValues) {
        for (let i = 0; i < Object.keys(cardColors).length; i++) {
          const color = Object.keys(cardColors)[i];
          loadedImgs[value + color] = renderCard(shapes[color], value);
        }
      }
      loadedImgs["back"] = renderCard(null, "SPECIAL_BACK");
      const game = new Phaser.Game({
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        scene: {
          preload: function () {
            for (let value of cardValues) {
              for (let i = 0; i < Object.keys(cardColors).length; i++) {
                const color = Object.keys(cardColors)[i];
                this.load.image(
                  value + color,
                  loadedImgs[value + color].src,
                );
              }
            }
            this.load.image("playerListArrow","/assets/arrow.png")
            this.load.image("back", loadedImgs["back"].src);
            this.load.image("background", "/assets/gradient.png");
            this.load.image("dutchBtn","/assets/dutchButton.png");
            this.load.audioSprite("cardFlaps","/assets/cardFlaps.json",["/assets/cardFlaps.ogg"]);
          },
          create: create,
          update: update
        },
      });
      function create() {
        scene = this;
        camera = this.cameras.main;
        //console.log(scene.graphics);
        handGroup = this.add.group();
        backgroundImg = scene.add.sprite(window.innerWidth/2,window.innerHeight/2,"background");
        backgroundImg.setScrollFactor(0.3);
        backgroundImg.setScale(5.3);
        table = scene.add.graphics();
        table.fillStyle(0x87552a);
        table.lineStyle(4,0x6b4421);
        table.fillCircle(window.innerWidth/2,window.innerHeight/2,500);
        table.strokeCircle(window.innerWidth/2,window.innerHeight/2,500);
        table.setScrollFactor(0.7);
        playerListArrowObject = scene.add.sprite(0,0,"playerListArrow");
        playerListArrowObject.setScrollFactor(0);
        playerListArrowObject.setScale(0.6);
        dutchButton = scene.add.sprite(window.innerWidth/2,window.innerHeight/2-200,"dutchBtn");
        dutchButton.setScrollFactor(0.7);
        dutchButton.setScale(0.6);
        dutchButton.setInteractive();
        dutchButton.on("pointerover", function(pointer){
          this.setScale(0.7);
        });
        dutchButton.on("pointerout",function(p){
          this.setScale(0.6);
        });
        socket.emit("connectToGame", {
          tempId: sessionStorage.getItem("tempId"),
        });
        socket.on("fixDesync",fixDesync);
        socket.on("updateHand", (data) => {
          hand = [];
          if (typeof data.hand == "number"){
            for (let i = 0;i<data.hand;i++){
              hand[i] = "back";
            }
          }
          else
            hand = data.hand;
          console.log(data.hand);
          displayHand();
          
        });
        socket.on("updateDiscard",(data) =>{
          if (data.discarded != null){
            displayPlacedCard(data.discarded);
          }
        });
        displayDeckCard("back");
        displayPlacedCard("back");
        socket.on("revealDeckCard",function(data){
          displayDeckCard(data.card);
          replaceMode = true;
          replaceFromMainDeck = true;
        });
        socket.on("confirmDrawFromDiscard",function(data){
          replaceMode = true;
          replaceFromMainDeck = false;
        });
        socket.on("canSeeCard",function(data){
          revealMode = true;
          revealAmount = data.amount;
        })
        socket.on("revealHeldCard",function(data){
          hand[data.id] = data.card;
          displayHand();
          setTimeout(() => {
            hand[data.id] = "back";
            displayHand();
          },5000);
        });
        socket.on("gameEnd",function(data){
          sessionStorage.setItem("gameResults",JSON.stringify(data));
          location.reload();
        });
        socket.on("playerUpdate",function(data){
          playerList = data.players;
          displayPlayerList();
        })
        socket.on("playerAction",function(data){
          
          if (data.source == "deckToDiscard"){
            setAnimation(data.card,{x:window.innerWidth/2-100,y:window.innerHeight/2},{x:window.innerWidth/2+100,y:window.innerHeight/2},0.4,0.36,100);

          }
          else if (data.source == "deck"){
            if (data.player == "you"){
            
              setAnimation(data.card,{x:window.innerWidth/2-100,y:window.innerHeight/2},{x:window.innerWidth/2,y:window.innerHeight-30},0.4,0.36,200);
              setAnimation("back",{x:window.innerWidth/2,y:window.innerHeight-30},{x:window.innerWidth/2+100,y:window.innerHeight/2},0.4,0.36,200);
            }
          }
          else if (data.source == "discard"){
            if (data.player == "you"){
            
              setAnimation(data.card,{x:window.innerWidth/2+100,y:window.innerHeight/2},{x:window.innerWidth/2,y:window.innerHeight-30},0.4,0.36,200);
              setAnimation("back",{x:window.innerWidth/2,y:window.innerHeight-30},{x:window.innerWidth/2+100,y:window.innerHeight/2},0.4,0.36,200);
            }
          }
          else if (data.source == "throwCard(sucess)"){
            if (data.player == "you"){
              setAnimation(data.card,{x:window.innerWidth/2,y:window.innerHeight-30},{x:window.innerWidth/2+100,y:window.innerHeight/2},0.4,0.36,200);
            }
          }
          else if (data.source == "throwCard(fail)"){
            if (data.player == "you"){
            
              setAnimation(data.card,{x:window.innerWidth/2,y:window.innerHeight-30},{x:window.innerWidth/2+100,y:window.innerHeight/2},0.4,0.36,200);
              setAnimation("back",{x:window.innerWidth/2-100,y:window.innerHeight/2},{x:window.innerWidth/2,y:window.innerHeight-30},0.4,0.36,200);
              
              setTimeout(function(){
                setAnimation("back",{x:window.innerWidth/2-100,y:window.innerHeight/2},{x:window.innerWidth/2,y:window.innerHeight-30},0.4,0.36,200);
              },50);
            }
          }
        })
      }
      function update(frame,deltaTime){
        camera.setScroll((scene.input.mousePointer.x - (window.innerWidth / 2)) / mouseMovementScale,(scene.input.mousePointer.y - (window.innerHeight / 2)) / mouseMovementScale);
        for (let i = 0;i<animationData.length;i++){
          if (animationData[i] != undefined && animationData[i].isAnimating){
            animationData[i].step += deltaTime;
            animationCard[i].x = Phaser.Math.Linear(animationData[i].startx,animationData[i].destinationx, animationData[i].step/animationData[i].duration);
            animationCard[i].y = Phaser.Math.Linear(animationData[i].starty,animationData[i].destinationy, animationData[i].step/animationData[i].duration);
            animationCard[i] .setScale(Phaser.Math.Linear(animationData[i].startScale,animationData[i].destinationScale,animationData[i].step/animationData[i].duration));
            if (animationData[i].step >= animationData[i].duration){
              animationData[i].isAnimating = false;
              animationCard[i].destroy();
              animationCard[i] = undefined;
              animationData[i] = undefined;
            }
          }
        }
      }
      function displayDeckCard(cardToDisplay){
        if (!!deckCard){
          deckCard.destroy();
        }
        deckCard = scene.add.sprite(window.innerWidth/2-100,window.innerHeight/2,cardToDisplay);
        deckCard.setScale(0.36)
        deckCard.setScrollFactor(0.7);
        deckCard.setInteractive();
        deckCard.on("pointerover", function(pointer){
          this.setScale(0.5);
        });
        deckCard.on("pointerout",function(p){
          this.setScale(0.36);
        });
        deckCard.on("pointerdown",function(pointer){
          socket.emit("drawFromDeck");
          scene.sound.playAudioSprite("cardFlaps","flap0"+RandomInt(1,2),{detune: RandomInt(-700,700),});
        });
      }
      function displayPlacedCard(cardToDisplay){
        if (!!placedCard){
          placedCard.destroy();
        }
        placedCard = scene.add.sprite(window.innerWidth/2+100,window.innerHeight/2,cardToDisplay);
        placedCard.setScale(0.36)
        placedCard.setScrollFactor(0.7);
        placedCard.setInteractive();
        placedCard.on("pointerover", function(pointer){
          this.setScale(0.5);
        });
        placedCard.on("pointerout",function(p){
          this.setScale(0.36);
        });
        placedCard.on("pointerdown",function(pointer){
          scene.sound.playAudioSprite("cardFlaps","flap0"+RandomInt(1,2),{detune: RandomInt(-700,700),});
          if (!replaceMode){
            socket.emit("drawFromDiscard");
          }
          else{
            socket.emit("replaceCard", {card: -1,source:"deck"});
                replaceMode = false;
                displayDeckCard("back");
          }
        });
      }
      function displayHand(){
        for (let c of cards){
          c.destroy();
        }
        for (let i = 0; i < hand.length;i++){
            cards[i] = scene.add.sprite((window.innerWidth / 2 + (i-hand.length/2)*80) + (i<(hand.length-1)/2 ? getDistanceBetween(i, (hand.length-1)/2) : -getDistanceBetween(i, (hand.length-1)/2))*30, window.innerHeight - 30 + getDistanceBetween(i, (hand.length-1)/2) * 10, hand[i]);
            cards[i].setScale(0.4);
            cards[i].setInteractive();
            cards[i].setRotation(i<hand.length/2 ? -getDistanceBetween(i,(hand.length-1)/2)*0.1 : getDistanceBetween(i,(hand.length-1)/2)*0.1);
            //handGroup.add(cards[i]);
            cards[i].on('pointerover', function (pointer) {
                this.y -= 20;
            });
            cards[i].on('pointerout', function (pointer) {
                this.y += 20;
            });
            cards[i].on('pointerdown', function (pointer) {
              scene.sound.playAudioSprite("cardFlaps","flap0"+RandomInt(1,2),{detune: RandomInt(-700,700),});
              if (revealMode){
                revealAmount--;
                socket.emit("selectSeeCard",{card:i});
                  if (revealAmount == 0){
                  revealMode = false;
                }
                return;
              }
              else if (!replaceMode)
                socket.emit("playCard", { card: i });
              else{
                if (replaceFromMainDeck)
                {
                  socket.emit("replaceCard", {card: i,source:"deck"});
                  
                }
                else{
                  socket.emit("replaceCard", {card: i,source:"discard"});
                  setAnimation("back",{x:window.innerWidth/2,y:window.innerHeight-30},{x:window.innerWidth/2+100,y:window.innerHeight/2},0.4,0.36,200);
                }
                replaceMode = false;
                displayDeckCard("back");
              }
            });

        }
      }
      function displayOpponentHand(player){
        for (let c of opponentCards){
          c.destroy();
        }
        for (let i = 0; i < playerList[player].hand;i++){
            opponentCards[i] = scene.add.sprite((window.innerWidth / 2 + (i-playerList[player].hand/2)*80) + (i<(playerList[player].hand-1)/2 ? getDistanceBetween(i, (playerList[player].hand-1)/2) : -getDistanceBetween(i, (playerList[player].hand-1)/2))*30, 0 + 30 - getDistanceBetween(i, (playerList[player].hand-1)/2) * 10, "back");
            opponentCards[i].setScale(0.4);
            opponentCards[i].setInteractive();
            opponentCards[i].setFlip(false,true);
            opponentCards[i].setRotation(i<playerList[player].hand/2 ? -getDistanceBetween(i,(playerList[player].hand-1)/2)*0.1 : getDistanceBetween(i,(playerList[player].hand-1)/2)*0.1);
            //handGroup.add(cards[i]);
            opponentCards[i].on('pointerover', function (pointer) {
                this.y -= 20;
            });
            opponentCards[i].on('pointerout', function (pointer) {
                this.y += 20;
            });
            opponentCards[i].on('pointerdown', function (pointer) {
              scene.sound.playAudioSprite("cardFlaps","flap0"+RandomInt(1,2),{detune: RandomInt(-700,700),});
              if (revealMode){
                revealAmount--;
                socket.emit("selectSeeCard",{card:i});
                  if (revealAmount == 0){
                  revealMode = false;
                }
                return;
              }
              if (!replaceMode)
                socket.emit("playCard", { card: i });
              else{
                if (replaceFromMainDeck)
                  socket.emit("replaceCard", {card: i,source:"deck"});
                else
                  socket.emit("replaceCard", {card: i,source:"discard"});
                replaceMode = false;
                displayDeckCard("back");
              }
            });

        }
      }
      function displayPlayerList(){
        for (p of playerListObjects){
          p[0].destroy();
          p[1].destroy();
        }
        for (let i = 0;i < playerList.length;i++){
          let hitbox = new Phaser.Geom.Rectangle(window.innerWidth-100,i*55,100,50);
          playerListObjects[i] = [];
          playerListObjects[i][0] = scene.add.graphics();
          playerListObjects[i][0].fillStyle(0xFFFFFF,0.7);
          playerListObjects[i][0].fillRoundedRect(window.innerWidth-100,i*55,100,50);
          playerListObjects[i][1] = scene.add.text(window.innerWidth-90,i*55+20,playerList[i].name,{align:"center",color:"#000000"});
          playerListObjects[i][0].setInteractive(hitbox, Phaser.Geom.Rectangle.Contains);
          playerListObjects[i][0].setScrollFactor(0);
          playerListObjects[i][1].setScrollFactor(0);
          console.log(playerListObjects[i][0].index);
          console.log(playerListObjects[i][0]);
          playerListObjects[i][0].on("pointerdown",function(pointer){
            playerListArrowObject.y = i*55;
            playerListArrowObject.x = window.innerWidth-100;
            displayOpponentHand(i);
          });
        }
      }
      function setAnimation(textureId,p1,p2,s1,s2,t){
        let index;
        if (animationData.length == 0){
          index = 0;
        }
        else{
          let i = 0;
          while (animationData[i] != undefined)
          {
            i++;
          }
          index = i;
        }
        animationCard[index] = scene.add.sprite(p1.x,p1.y,textureId);
        animationCard[index].setScale(s1);
        animationData[index] = {};
        animationData[index].startScale = s1;
        animationData[index].destinationScale = s2;
        animationData[index].destinationx = p2.x;
        animationData[index].destinationy = p2.y;
        animationData[index].startx = p1.x;
        animationData[index].starty = p1.y;
        animationData[index].step = 0;
        animationData[index].duration = t;
        animationData[index].isAnimating = true;
      }
      function fixDesync(){
        replaceMode = false;
        revealMode = false;
        revealAmount = 0;
      }
    });
    function debug (msg) {
      socket.emit("debug", msg);
    }
    function getDistanceBetween(val1,val2){
      let ret = val1 - val2;
      if (ret < 0){
        ret = -ret;
      }
      return ret;
    }
    function RandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
  </script>
</html>
