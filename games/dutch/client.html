<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      @font-face {
        font-family: lato;
        src: url(/assets/fonts/lato/Lato-Black.ttf);
      }
      canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        left: 0px;
        top: 0px;
      }
      </style>
  </head>
  <body></body>
  <script src="/libs/phaser.js"></script>
  <script src="/engine.js"></script>
  <script src="/card-generator"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    console.log(io);
    const socket = io();
    socket.on("connection", (e) => {
      
    });
    const cardColors = { h: "red", d: "#9e5515", s: "black", c: "blue" };
    const cardValues = ["A", 2, 3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K"];
    const shapes = {};
    const cards = {};
    const loadedImgs = {};
    const mouseMovementScale = 10;
    var camera;
    var handGroup;
    var deckCard;
    var placedCard;
    var backgroundImg;
    var table;
    var replaceMode = false;
    var replaceFromMainDeck = true;
    var revealMode = false;
    var revealAmount = 0;
    const loadPromise = new Promise((resolve, reject) => {
      let loaded = 0;
      for (let i = 0; i < Object.keys(cardColors).length; i++) {
        const color = Object.keys(cardColors)[i];
        shapes[color] = new shape(
          cardColors[color],
          "/assets/" + color + "_symbol.png",
          function () {
            loaded++;
          },
        );
      }
      var checker = setInterval(() => {
        if (loaded >= 4) {
          clearInterval(checker);
          resolve();
        }
      }, 100);
    }).then(() => {
      var scene;
      const cards = [];
      for (let value of cardValues) {
        for (let i = 0; i < Object.keys(cardColors).length; i++) {
          const color = Object.keys(cardColors)[i];
          loadedImgs[value + color] = renderCard(shapes[color], value);
        }
      }
      loadedImgs["back"] = renderCard(null, "SPECIAL_BACK");
      const game = new Phaser.Game({
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        scene: {
          preload: function () {
            for (let value of cardValues) {
              for (let i = 0; i < Object.keys(cardColors).length; i++) {
                const color = Object.keys(cardColors)[i];
                this.load.image(
                  value + color,
                  loadedImgs[value + color].src,
                );
              }
            }
            this.load.image("back", loadedImgs["back"].src);
            this.load.image("background", "/assets/gradient.png")
          },
          create: create,
          update: update
        },
      });
      function create() {
        scene = this;
        camera = this.cameras.main;
        //console.log(scene.graphics);
        handGroup = this.add.group();
        backgroundImg = scene.add.sprite(window.innerWidth/2,window.innerHeight/2,"background");
        backgroundImg.setScrollFactor(0.3);
        backgroundImg.setScale(5.3);
        table = scene.add.graphics();
        table.fillStyle(0x87552a);
        table.lineStyle(4,0x6b4421);
        table.fillCircle(window.innerWidth/2,window.innerHeight/2,500);
        table.strokeCircle(window.innerWidth/2,window.innerHeight/2,500);
        table.setScrollFactor(0.7);
        socket.emit("connectToGame", {
          tempId: sessionStorage.getItem("tempId"),
        });
        socket.on("fixDesync",fixDesync);
        socket.on("updateHand", (data) => {
          hand = [];
          if (typeof data.hand == "number"){
            for (let i = 0;i<data.hand;i++){
              hand[i] = "back";
            }
          }
          else
            hand = data.hand;
          console.log(data.hand);
          displayHand();
          
        });
        socket.on("updateDiscard",(data) =>{
          if (data.discarded != null){
            displayPlacedCard(data.discarded);
          }
        });
        displayDeckCard("back");
        displayPlacedCard("back");
        socket.on("revealDeckCard",function(data){
          displayDeckCard(data.card);
          replaceMode = true;
          replaceFromMainDeck = true;
        });
        socket.on("confirmDrawFromDiscard",function(data){
          replaceMode = true;
          replaceFromMainDeck = false;
        });
        socket.on("canSeeCard",function(data){
          revealMode = true;
          revealAmount = data.amount;
        })
        socket.on("revealHeldCard",function(data){
          hand[data.id] = data.card;
          displayHand();
          setTimeout(() => {
            hand[data.id] = "back";
            displayHand();
          },5000);
        });
      }
      function update(){
        camera.setScroll((scene.input.mousePointer.x - (window.innerWidth / 2)) / mouseMovementScale,(scene.input.mousePointer.y - (window.innerHeight / 2)) / mouseMovementScale);
      }
      function displayDeckCard(cardToDisplay){
        if (!!deckCard){
          deckCard.destroy();
        }
        deckCard = scene.add.sprite(window.innerWidth/2-100,window.innerHeight/2,cardToDisplay);
        deckCard.setScale(0.36)
        deckCard.setScrollFactor(0.7);
        deckCard.setInteractive();
        deckCard.on("pointerover", function(pointer){
          this.setScale(0.5);
        });
        deckCard.on("pointerout",function(p){
          this.setScale(0.4);
        });
        deckCard.on("pointerdown",function(pointer){
          socket.emit("drawFromDeck");
        });
      }
      function displayPlacedCard(cardToDisplay){
        if (!!placedCard){
          placedCard.destroy();
        }
        placedCard = scene.add.sprite(window.innerWidth/2+100,window.innerHeight/2,cardToDisplay);
        placedCard.setScale(0.36)
        placedCard.setScrollFactor(0.7);
        placedCard.setInteractive();
        placedCard.on("pointerover", function(pointer){
          this.setScale(0.5);
        });
        placedCard.on("pointerout",function(p){
          this.setScale(0.4);
        });
        placedCard.on("pointerdown",function(pointer){
          if (!replaceMode){
            socket.emit("drawFromDiscard");
          }
          else{
            socket.emit("replaceCard", {card: -1,source:"deck"});
                replaceMode = false;
                displayDeckCard("back");
          }
        });
      }
      function displayHand(){
        for (let c of cards){
          c.destroy();
        }
        for (let i = 0; i < hand.length;i++){
            cards[i] = scene.add.sprite((window.innerWidth / 2 + (i-hand.length/2)*80) + (i<(hand.length-1)/2 ? getDistanceBetween(i, (hand.length-1)/2) : -getDistanceBetween(i, (hand.length-1)/2))*30, window.innerHeight - 30 + getDistanceBetween(i, (hand.length-1)/2) * 10, hand[i]);
            cards[i].setScale(0.4);
            cards[i].setInteractive();
            cards[i].setRotation(i<hand.length/2 ? -getDistanceBetween(i,(hand.length-1)/2)*0.1 : getDistanceBetween(i,(hand.length-1)/2)*0.1);
            //handGroup.add(cards[i]);
            cards[i].on('pointerover', function (pointer) {
                this.y -= 20;
            });
            cards[i].on('pointerout', function (pointer) {
                this.y += 20;
            });
            cards[i].on('pointerdown', function (pointer) {
              if (revealMode){
                revealAmount--;
                socket.emit("selectSeeCard",{card:i});
                  if (revealAmount == 0){
                  revealMode = false;
                }
                return;
              }
              if (!replaceMode)
                socket.emit("playCard", { card: i });
              else{
                if (replaceFromMainDeck)
                  socket.emit("replaceCard", {card: i,source:"deck"});
                else
                  socket.emit("replaceCard", {card: i,source:"discard"});
                replaceMode = false;
                displayDeckCard("back");
              }
            });

        }
      }
      function fixDesync(){
        replaceMode = false;
        revealMode = false;
        revealAmount = 0;
      }
    });
    function debug (msg) {
      socket.emit("debug", msg);
    }
    function getDistanceBetween(val1,val2){
      let ret = val1 - val2;
      if (ret < 0){
        ret = -ret;
      }
      return ret;
    }
  </script>
</html>
